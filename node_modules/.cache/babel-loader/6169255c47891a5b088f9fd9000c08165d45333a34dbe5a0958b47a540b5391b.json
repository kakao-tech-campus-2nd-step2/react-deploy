{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIncomingMessageBody = void 0;\nvar debug_1 = require(\"debug\");\nvar stream_1 = require(\"stream\");\nvar zlib = __importStar(require(\"zlib\"));\nvar log = debug_1.debug('http getIncomingMessageBody');\nfunction getIncomingMessageBody(response) {\n  return new Promise(function (resolve, reject) {\n    log('cloning the original response...');\n    // Pipe the original response to support non-clone\n    // \"response\" input. No need to clone the response,\n    // as we always have access to the full \"response\" input,\n    // either a clone or an original one (in tests).\n    var responseClone = response.pipe(new stream_1.PassThrough());\n    var stream = response.headers['content-encoding'] === 'gzip' ? responseClone.pipe(zlib.createGunzip()) : responseClone;\n    var encoding = response.readableEncoding || 'utf8';\n    stream.setEncoding(encoding);\n    log('using encoding:', encoding);\n    var body = '';\n    stream.on('data', function (responseBody) {\n      log('response body read:', responseBody);\n      body += responseBody;\n    });\n    stream.once('end', function () {\n      log('response body end');\n      resolve(body);\n    });\n    stream.once('error', function (error) {\n      log('error while reading response body:', error);\n      reject(error);\n    });\n  });\n}\nexports.getIncomingMessageBody = getIncomingMessageBody;","map":{"version":3,"names":["debug_1","require","stream_1","zlib","__importStar","log","debug","getIncomingMessageBody","response","Promise","resolve","reject","responseClone","pipe","PassThrough","stream","headers","createGunzip","encoding","readableEncoding","setEncoding","body","on","responseBody","once","error","exports"],"sources":["/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/@mswjs/interceptors/src/interceptors/ClientRequest/utils/getIncomingMessageBody.ts"],"sourcesContent":["import { debug } from 'debug'\nimport { IncomingMessage } from 'http'\nimport { PassThrough } from 'stream'\nimport * as zlib from 'zlib'\n\nconst log = debug('http getIncomingMessageBody')\n\nexport function getIncomingMessageBody(\n  response: IncomingMessage\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    log('cloning the original response...')\n\n    // Pipe the original response to support non-clone\n    // \"response\" input. No need to clone the response,\n    // as we always have access to the full \"response\" input,\n    // either a clone or an original one (in tests).\n    const responseClone = response.pipe(new PassThrough())\n    const stream =\n      response.headers['content-encoding'] === 'gzip'\n        ? responseClone.pipe(zlib.createGunzip())\n        : responseClone\n\n    const encoding = response.readableEncoding || 'utf8'\n    stream.setEncoding(encoding)\n    log('using encoding:', encoding)\n\n    let body = ''\n\n    stream.on('data', (responseBody) => {\n      log('response body read:', responseBody)\n      body += responseBody\n    })\n\n    stream.once('end', () => {\n      log('response body end')\n      resolve(body)\n    })\n\n    stream.once('error', (error) => {\n      log('error while reading response body:', error)\n      reject(error)\n    })\n  })\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAEA,IAAAC,QAAA,GAAAD,OAAA;AACA,IAAAE,IAAA,GAAAC,YAAA,CAAAH,OAAA;AAEA,IAAMI,GAAG,GAAGL,OAAA,CAAAM,KAAK,CAAC,6BAA6B,CAAC;AAEhD,SAAgBC,sBAAsBA,CACpCC,QAAyB;EAEzB,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;IACjCN,GAAG,CAAC,kCAAkC,CAAC;IAEvC;IACA;IACA;IACA;IACA,IAAMO,aAAa,GAAGJ,QAAQ,CAACK,IAAI,CAAC,IAAIX,QAAA,CAAAY,WAAW,EAAE,CAAC;IACtD,IAAMC,MAAM,GACVP,QAAQ,CAACQ,OAAO,CAAC,kBAAkB,CAAC,KAAK,MAAM,GAC3CJ,aAAa,CAACC,IAAI,CAACV,IAAI,CAACc,YAAY,EAAE,CAAC,GACvCL,aAAa;IAEnB,IAAMM,QAAQ,GAAGV,QAAQ,CAACW,gBAAgB,IAAI,MAAM;IACpDJ,MAAM,CAACK,WAAW,CAACF,QAAQ,CAAC;IAC5Bb,GAAG,CAAC,iBAAiB,EAAEa,QAAQ,CAAC;IAEhC,IAAIG,IAAI,GAAG,EAAE;IAEbN,MAAM,CAACO,EAAE,CAAC,MAAM,EAAE,UAACC,YAAY;MAC7BlB,GAAG,CAAC,qBAAqB,EAAEkB,YAAY,CAAC;MACxCF,IAAI,IAAIE,YAAY;IACtB,CAAC,CAAC;IAEFR,MAAM,CAACS,IAAI,CAAC,KAAK,EAAE;MACjBnB,GAAG,CAAC,mBAAmB,CAAC;MACxBK,OAAO,CAACW,IAAI,CAAC;IACf,CAAC,CAAC;IAEFN,MAAM,CAACS,IAAI,CAAC,OAAO,EAAE,UAACC,KAAK;MACzBpB,GAAG,CAAC,oCAAoC,EAAEoB,KAAK,CAAC;MAChDd,MAAM,CAACc,KAAK,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AArCAC,OAAA,CAAAnB,sBAAA,GAAAA,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}