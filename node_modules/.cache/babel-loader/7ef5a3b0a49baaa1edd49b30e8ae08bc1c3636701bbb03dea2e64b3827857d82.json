{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// config/polyfills-node.ts\nimport { setTimeout as nodeSetTimeout } from \"timers\";\nvar setTimeout = nodeSetTimeout;\n\n// src/node/SetupServerApi.ts\nimport chalk from \"chalk\";\nimport { invariant as invariant3 } from \"outvariant\";\nimport { BatchInterceptor, InterceptorReadyState } from \"@mswjs/interceptors\";\n\n// src/SetupApi.ts\nimport { invariant } from \"outvariant\";\nimport { Emitter } from \"strict-event-emitter\";\n\n// src/utils/internal/devUtils.ts\nimport { format } from \"outvariant\";\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = format(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new Emitter();\n    this.publicEmitter = new Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      invariant(!Array.isArray(handler), devUtils.formatMessage('Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'), this.constructor.name);\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach(handler => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\nimport * as cookieUtils2 from \"cookie\";\nimport { store } from \"@mswjs/cookies\";\nimport { IsomorphicRequest } from \"@mswjs/interceptors\";\nimport { decodeBuffer } from \"@mswjs/interceptors/lib/utils/bufferUtils.js\";\nimport { Headers } from \"headers-polyfill\";\n\n// src/utils/request/getRequestCookies.ts\nimport * as cookieUtils from \"cookie\";\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nimport { stringToHeaders } from \"headers-polyfill\";\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = decodeBuffer(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils2.parse(requestCookiesString) : {};\n    store.hydrate();\n    const cookiesFromStore = Array.from((_a = store.get({\n      ...this,\n      url: this.url.href\n    })) == null ? void 0 : _a.entries()).reduce((cookies, [name, {\n      value\n    }]) => {\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/handleRequest.ts\nimport { until } from \"@open-draft/until\";\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nimport getStringMatchScore from \"js-levenshtein\";\n\n// src/utils/internal/parseGraphQLRequest.ts\nimport { parse as parse3 } from \"graphql\";\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = parse3(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const {\n            operations,\n            map,\n            ...files\n          } = request.body;\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nimport { objectToHeaders } from \"headers-polyfill\";\nfunction set(...args) {\n  return res => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = objectToHeaders(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nimport * as cookieUtils3 from \"cookie\";\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils3.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nimport { isNodeProcess } from \"is-node-process\";\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nimport { isNodeProcess as isNodeProcess2 } from \"is-node-process\";\nimport { Headers as Headers2 } from \"headers-polyfill\";\nvar useFetch = isNodeProcess2() ? (input, init) => Promise.resolve().then(() => __toESM(__require(\"node-fetch\"))).then(({\n  default: nodeFetch\n}) => nodeFetch(input, init)) : globalThis.fetch;\nvar augmentRequestInit = requestInit => {\n  const headers = new Headers2(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nimport { objectToHeaders as objectToHeaders2 } from \"headers-polyfill\";\nfunction prepareResponse(res) {\n  const responseHeaders = objectToHeaders2(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nimport { match } from \"path-to-regexp\";\nimport { getCleanUrl } from \"@mswjs/interceptors/lib/utils/getCleanUrl.js\";\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = getCleanUrl(url);\n  const result = match(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nimport { Headers as Headers4 } from \"headers-polyfill\";\n\n// src/response.ts\nimport { Headers as Headers3 } from \"headers-polyfill\";\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new Headers3({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nimport { invariant as invariant2 } from \"outvariant\";\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  invariant2(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  invariant2(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  invariant2(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  invariant2(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(request, (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {}, (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\");\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = getStringMatchScore(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = getStringMatchScore(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nimport { store as store2 } from \"@mswjs/cookies\";\nfunction readResponseCookies(request, response2) {\n  store2.add({\n    ...request,\n    url: request.url.toString()\n  }, response2);\n  store2.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar {\n  bold\n} = chalk;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: \"warn\"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors, ...handlers) {\n    super(...handlers);\n    this.interceptor = new BatchInterceptor({\n      name: \"setup-server\",\n      interceptors: interceptors.map(Interceptor2 => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on(\"request\", async request => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer()\n      });\n      const response2 = await handleRequest(mockedRequest, this.currentHandlers, this.resolvedOptions, this.emitter, {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        }\n      });\n      if (response2) {\n        if (response2.delay) {\n          await new Promise(resolve => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on(\"response\", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n        this.emitter.emit(\"response:mocked\", response2, request.id);\n      } else {\n        this.emitter.emit(\"response:bypass\", response2, request.id);\n      }\n    });\n  }\n  listen(options = {}) {\n    this.resolvedOptions = mergeRight(DEFAULT_LISTEN_OPTIONS, options);\n    this.interceptor.apply();\n    invariant3([InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(this.interceptor.readyState), devUtils.formatMessage('Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".'), \"https://github.com/mswjs/msw/issues/new/choose\");\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach(handler => {\n      const {\n        header,\n        callFrame\n      } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.log(`${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`);\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\nimport { ClientRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/ClientRequest/index.js\";\nimport { XMLHttpRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\";\nimport { FetchInterceptor } from \"@mswjs/interceptors/lib/interceptors/fetch/index.js\";\nvar setupServer = (...handlers) => {\n  return new SetupServerApi([ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor], ...handlers);\n};\nexport { SetupServerApi, setupServer };","map":{"version":3,"names":["setTimeout","nodeSetTimeout","chalk","invariant","invariant3","BatchInterceptor","InterceptorReadyState","Emitter","format","LIBRARY_PREFIX","formatMessage","message","positionals","interpolatedMessage","warn","console","error","devUtils","pipeEvents","source","destination","rawEmit","emit","_isPiped","event","data2","call","toReadonlyArray","clone","Object","freeze","SetupApi","constructor","initialHandlers","validateHandlers","currentHandlers","emitter","publicEmitter","events","createLifeCycleEvents","handlers","handler","Array","isArray","name","dispose","removeAllListeners","use","runtimeHandlers","unshift","restoreHandlers","forEach","markAsSkipped","resetHandlers","nextHandlers","length","listHandlers","on","args","removeListener","isObject","value","mergeRight","left","right","entries","reduce","result","key","rightValue","leftValue","concat","assign","cookieUtils2","store","IsomorphicRequest","decodeBuffer","Headers","cookieUtils","getAllCookies","parse","document","cookie","getRequestCookies","request","location","credentials","origin","url","jsonParse","JSON","error2","stringToHeaders","parseContentHeaders","headersString","_a","_b","headers","contentType","get","disposition","Error","directives","split","acc","chunk","name2","rest","trim","join","slice","filename","parseMultipartData","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","contentType2","File","type","parsedValue","parseBody","body2","toLowerCase","hasMultipartContent","toString","hasJsonContent","includes","isStringEqual","actual","expected","MockedRequest","init","id","cache","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","body","text2","method","passthrough","status","statusText","once","requestCookiesString","ownCookies","hydrate","cookiesFromStore","from","href","cookiesFromDocument","forwardedCookies","append","until","getResponse","resolutionContext","relevantHandlers","test","response","executionResult","previousResults","result2","run","shouldSkip","parsedResult","Promise","resolve","publicRequest","parsedRequest","getStringMatchScore","parse3","getPublicUrlFromRequest","pathname","URL","protocol","host","parseDocumentNode","node","operationDef","definitions","find","def","kind","operationType","operation","operationName","parseQuery","query","ast","extractMultipartVariables","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","getGraphQLInput","searchParams","parsedOperations","parsedMap","parseGraphQLRequest","input","requestPublicUrl","statusCode","res","codes_default","String","objectToHeaders","set","value2","cookieUtils3","options","serializedCookie","serialize","json","stringify","data","payload","prevBody","nextBody","extensions","isNodeProcess","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","delay","durationOrMode","delayTime","errors","errorsList","isNodeProcess2","Headers2","useFetch","then","__toESM","__require","default","nodeFetch","globalThis","fetch","augmentRequestInit","requestInit","all","createFetchRequestParameters","requestParameters","derivedRequestInit","text","xml","getStatusCodeColor","status2","getTimestamp","now","Date","getHours","getMinutes","getSeconds","padStart","prepareRequest","objectToHeaders2","prepareResponse","responseHeaders","match","getCleanUrl","REDUNDANT_CHARACTERS_EXP","getSearchParams","cleanUrl","isAbsoluteUrl","getAbsoluteUrl","baseUrl","baseURI","decodeURI","encodeURI","normalizePath","maybeAbsoluteUrl","coercePath","_","parameterName","wildcard","expression","matchRequestUrl","normalizedPath","cleanPath","cleanUrl2","decode","decodeURIComponent","params","matches","Headers4","Headers3","compose","fns","reduceRight","leftFn","rightFn","NetworkError","defaultResponse","defaultResponseTransformers","createResponseComposition","responseOverrides","defaultTransformers","transformers","initialResponse","resolvedTransformers","Boolean","resolvedResponse","networkError","SOURCE_FRAME","BUILD_FRAME","getCallFrame","stack","frames","declarationFrame","frame","declarationPath","isIterable","fn","Symbol","iterator","defaultContext","RequestHandler","ctx","resolver","callFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","done","next","nextResponse","resolverGeneratorResult","response2","restContext","RestRequest","RestHandler","header","checkRedundantQueryParameters","queryParams","paramName","push","matchesMethod","log","publicUrl","loggedRequest","loggedResponse","statusColor","groupCollapsed","groupEnd","invariant2","field","fieldName","fieldValue","validateFieldName","tryCatch","onException","graphqlContext","isDocumentNode","GraphQLRequest","GraphQLHandler","endpoint","resolvedOperationName","parsedNode","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groupHandlersByType","groups","graphql","getRestHandlerScore","Infinity","hasSameMethod","methodScoreDelta","score","getGraphQLHandlerScore","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getSuggestedHandler","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","getSuggestedHandlersMessage","onUnhandledRequest","strategy","parsedGraphQLQuery","generateHandlerSuggestion","handlerGroups","generateUnhandledRequestMessage","requestHeader","handlerSuggestion","messageTemplate","applyStrategy","strategy2","warning","bind","store2","readResponseCookies","add","persist","handleRequest","handleRequestOptions","_c","_d","_e","_f","onPassthroughResponse","lookupError","lookupResult","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","bold","DEFAULT_LISTEN_OPTIONS","SetupServerApi","interceptors","interceptor","Interceptor2","resolvedOptions","mockedRequest","arrayBuffer","response3","respondWith","listen","apply","APPLYING","APPLIED","readyState","printHandlers","pragma","hasOwnProperty","close","ClientRequestInterceptor","XMLHttpRequestInterceptor","FetchInterceptor","setupServer"],"sources":["/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/config/polyfills-node.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/node/SetupServerApi.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/SetupApi.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/devUtils.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/pipeEvents.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/toReadonlyArray.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isObject.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/mergeRight.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/MockedRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/getRequestCookies.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/jsonParse.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/parseMultipartData.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/parseBody.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isStringEqual.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/handleRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/getResponse.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/onUnhandledRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/parseGraphQLRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/getPublicUrlFromRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/status.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/set.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/cookie.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/body.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/json.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/data.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/extensions.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/delay.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/errors.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/fetch.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/text.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/xml.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/getStatusCodeColor.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/getTimestamp.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/prepareRequest.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/logging/prepareResponse.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/matching/matchRequestUrl.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/cleanUrl.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/isAbsoluteUrl.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/url/getAbsoluteUrl.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/matching/normalizePath.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/RequestHandler.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/response.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/compose.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/NetworkError.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/getCallFrame.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/isIterable.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/RestHandler.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/context/field.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/internal/tryCatch.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/handlers/GraphQLHandler.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/utils/request/readResponseCookies.ts","/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/msw/src/node/setupServer.ts"],"sourcesContent":["import { setTimeout as nodeSetTimeout } from 'timers'\n\n// Polyfill the global \"setTimeout\" so MSW could be used\n// with \"jest.useFakeTimers()\". MSW response handling\n// is wrapped in \"setTimeout\", and without this polyfill\n// you'd have to manually advance the timers for the response\n// to finally resolve.\nexport const setTimeout = nodeSetTimeout\n","import chalk from 'chalk'\nimport { invariant } from 'outvariant'\nimport {\n  BatchInterceptor,\n  HttpRequestEventMap,\n  Interceptor,\n  InterceptorReadyState,\n  IsomorphicResponse,\n  MockedResponse as MockedInterceptedResponse,\n} from '@mswjs/interceptors'\nimport { SetupApi } from '../SetupApi'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { handleRequest } from '../utils/handleRequest'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { SetupServer } from './glossary'\n\n/**\n * @see https://github.com/mswjs/msw/pull/1399\n */\nconst { bold } = chalk\n\nexport type ServerLifecycleEventsMap = LifeCycleEventsMap<IsomorphicResponse>\n\nconst DEFAULT_LISTEN_OPTIONS: RequiredDeep<SharedOptions> = {\n  onUnhandledRequest: 'warn',\n}\n\nexport class SetupServerApi\n  extends SetupApi<ServerLifecycleEventsMap>\n  implements SetupServer\n{\n  protected readonly interceptor: BatchInterceptor<\n    Array<Interceptor<HttpRequestEventMap>>,\n    HttpRequestEventMap\n  >\n  private resolvedOptions: RequiredDeep<SharedOptions>\n\n  constructor(\n    interceptors: Array<{\n      new (): Interceptor<HttpRequestEventMap>\n    }>,\n    ...handlers: Array<RequestHandler>\n  ) {\n    super(...handlers)\n\n    this.interceptor = new BatchInterceptor({\n      name: 'setup-server',\n      interceptors: interceptors.map((Interceptor) => new Interceptor()),\n    })\n    this.resolvedOptions = {} as RequiredDeep<SharedOptions>\n\n    this.init()\n  }\n\n  /**\n   * Subscribe to all requests that are using the interceptor object\n   */\n  private init(): void {\n    this.interceptor.on('request', async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer(),\n      })\n\n      const response = await handleRequest<\n        MockedInterceptedResponse & { delay?: number }\n      >(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body,\n              delay: response.delay,\n            }\n          },\n        },\n      )\n\n      if (response) {\n        // Delay Node.js responses in the listener so that\n        // the response lookup logic is not concerned with responding\n        // in any way. The same delay is implemented in the worker.\n        if (response.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response.delay)\n          })\n        }\n\n        request.respondWith(response)\n      }\n\n      return\n    })\n\n    this.interceptor.on('response', (request, response) => {\n      if (!request.id) {\n        return\n      }\n\n      if (response.headers.get('x-powered-by') === 'msw') {\n        this.emitter.emit('response:mocked', response, request.id)\n      } else {\n        this.emitter.emit('response:bypass', response, request.id)\n      }\n    })\n  }\n\n  public listen(options: Partial<SharedOptions> = {}): void {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options,\n    ) as RequiredDeep<SharedOptions>\n\n    // Apply the interceptor when starting the server.\n    this.interceptor.apply()\n\n    // Assert that the interceptor has been applied successfully.\n    // Also guards us from forgetting to call \"interceptor.apply()\"\n    // as a part of the \"listen\" method.\n    invariant(\n      [InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState,\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".',\n      ),\n      'https://github.com/mswjs/msw/issues/new/choose',\n    )\n  }\n\n  public printHandlers(): void {\n    const handlers = this.listHandlers()\n\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info\n\n      const pragma = handler.info.hasOwnProperty('operationType')\n        ? '[graphql]'\n        : '[rest]'\n\n      console.log(`\\\n${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`)\n    })\n  }\n\n  public close(): void {\n    super.dispose()\n    this.interceptor.dispose()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { MockedRequest } from './utils/request/MockedRequest'\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> {\n  protected initialHandlers: ReadonlyArray<RequestHandler>\n  protected currentHandlers: Array<RequestHandler>\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    this.validateHandlers(...initialHandlers)\n\n    this.initialHandlers = toReadonlyArray(initialHandlers)\n    this.currentHandlers = [...initialHandlers]\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n  }\n\n  private validateHandlers(...handlers: ReadonlyArray<RequestHandler>): void {\n    // Guard against incorrect call signature of the setup API.\n    for (const handler of handlers) {\n      invariant(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.',\n        ),\n        this.constructor.name,\n      )\n    }\n  }\n\n  protected dispose(): void {\n    this.emitter.removeAllListeners()\n    this.publicEmitter.removeAllListeners()\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    this.currentHandlers.unshift(...runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false)\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.currentHandlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<\n      RequestHandlerDefaultInfo,\n      MockedRequest<DefaultBodyType>,\n      any,\n      MockedRequest<DefaultBodyType>\n    >\n  > {\n    return toReadonlyArray(this.currentHandlers)\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n\n  abstract printHandlers(): void\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils.js'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess()\n    ? (input, init) =>\n        import('node-fetch').then(({ default: nodeFetch }) =>\n          (nodeFetch as unknown as typeof window.fetch)(input, init),\n        )\n    : globalThis.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<string>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  // Parse a response JSON body for preview in the logs\n  const parsedBody = parseBody(res.body, responseHeaders)\n\n  return {\n    ...res,\n    body: parsedBody,\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl.js'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(\n    request: MockedRequest,\n    public readonly variables: Variables,\n    public readonly operationName: string,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(\n      request,\n      parsedResult?.variables ?? {},\n      parsedResult?.operationName ?? '',\n    )\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { ClientRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/ClientRequest/index.js'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch/index.js'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { SetupServer } from './glossary'\nimport { SetupServerApi } from './SetupServerApi'\n\n/**\n * Sets up a requests interception in Node.js with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n * @see {@link https://mswjs.io/docs/api/setup-server `setupServer`}\n */\nexport const setupServer = (\n  ...handlers: Array<RequestHandler>\n): SetupServer => {\n  return new SetupServerApi(\n    [ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor],\n    ...handlers,\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}