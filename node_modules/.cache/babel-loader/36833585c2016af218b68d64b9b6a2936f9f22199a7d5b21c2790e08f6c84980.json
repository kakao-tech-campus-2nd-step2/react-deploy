{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeClientRequest = void 0;\nvar http_1 = require(\"http\");\nvar until_1 = require(\"@open-draft/until\");\nvar headers_polyfill_1 = require(\"headers-polyfill\");\nvar concatChunkToBuffer_1 = require(\"./utils/concatChunkToBuffer\");\nvar normalizeClientRequestEndArgs_1 = require(\"./utils/normalizeClientRequestEndArgs\");\nvar toIsoResponse_1 = require(\"../../utils/toIsoResponse\");\nvar getIncomingMessageBody_1 = require(\"./utils/getIncomingMessageBody\");\nvar bodyBufferToString_1 = require(\"./utils/bodyBufferToString\");\nvar normalizeClientRequestWriteArgs_1 = require(\"./utils/normalizeClientRequestWriteArgs\");\nvar cloneIncomingMessage_1 = require(\"./utils/cloneIncomingMessage\");\nvar IsomorphicRequest_1 = require(\"../../IsomorphicRequest\");\nvar InteractiveIsomorphicRequest_1 = require(\"../../InteractiveIsomorphicRequest\");\nvar bufferUtils_1 = require(\"../../utils/bufferUtils\");\nvar NodeClientRequest = /** @class */function (_super) {\n  __extends(NodeClientRequest, _super);\n  function NodeClientRequest(_a, options) {\n    var _b = __read(_a, 3),\n      url = _b[0],\n      requestOptions = _b[1],\n      callback = _b[2];\n    var _this = _super.call(this, requestOptions, callback) || this;\n    _this.chunks = [];\n    _this.responseSource = 'mock';\n    _this.requestBody = [];\n    _this.log = options.log.extend(\"request \" + requestOptions.method + \" \" + url.href);\n    _this.log('constructing ClientRequest using options:', {\n      url: url,\n      requestOptions: requestOptions,\n      callback: callback\n    });\n    _this.url = url;\n    _this.options = requestOptions;\n    _this.emitter = options.emitter;\n    // Construct a mocked response message.\n    _this.response = new http_1.IncomingMessage(_this.socket);\n    return _this;\n  }\n  NodeClientRequest.prototype.write = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(normalizeClientRequestWriteArgs_1.normalizeClientRequestWriteArgs(args), 3),\n      chunk = _a[0],\n      encoding = _a[1],\n      callback = _a[2];\n    this.log('write:', {\n      chunk: chunk,\n      encoding: encoding,\n      callback: callback\n    });\n    this.chunks.push({\n      chunk: chunk,\n      encoding: encoding\n    });\n    this.requestBody = concatChunkToBuffer_1.concatChunkToBuffer(chunk, this.requestBody);\n    this.log('chunk successfully stored!', this.requestBody);\n    /**\n     * Prevent invoking the callback if the written chunk is empty.\n     * @see https://nodejs.org/api/http.html#requestwritechunk-encoding-callback\n     */\n    if (!chunk || chunk.length === 0) {\n      this.log('written chunk is empty, skipping callback...');\n    } else {\n      callback === null || callback === void 0 ? void 0 : callback();\n    }\n    // Do not write the request body chunks to prevent\n    // the Socket from sending data to a potentially existing\n    // server when there is a mocked response defined.\n    return true;\n  };\n  NodeClientRequest.prototype.end = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    this.log('end', args);\n    var _a = __read(normalizeClientRequestEndArgs_1.normalizeClientRequestEndArgs.apply(void 0, __spreadArray([], __read(args))), 3),\n      chunk = _a[0],\n      encoding = _a[1],\n      callback = _a[2];\n    this.log('normalized arguments:', {\n      chunk: chunk,\n      encoding: encoding,\n      callback: callback\n    });\n    var requestBody = this.getRequestBody(chunk);\n    var isomorphicRequest = this.toIsomorphicRequest(requestBody);\n    var interactiveIsomorphicRequest = new InteractiveIsomorphicRequest_1.InteractiveIsomorphicRequest(isomorphicRequest);\n    // Notify the interceptor about the request.\n    // This will call any \"request\" listeners the users have.\n    this.log('emitting the \"request\" event for %d listener(s)...', this.emitter.listenerCount('request'));\n    this.emitter.emit('request', interactiveIsomorphicRequest);\n    // Execute the resolver Promise like a side-effect.\n    // Node.js 16 forces \"ClientRequest.end\" to be synchronous and return \"this\".\n    until_1.until(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, mockedResponse;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              return [4 /*yield*/, this.emitter.untilIdle('request', function (_a) {\n                var _b = __read(_a.args, 1),\n                  request = _b[0];\n                /**\n                 * @note Await only those listeners that are relevant to this request.\n                 * This prevents extraneous parallel request from blocking the resolution\n                 * of another, unrelated request. For example, during response patching,\n                 * when request resolution is nested.\n                 */\n                return request.id === interactiveIsomorphicRequest.id;\n              })];\n            case 1:\n              _b.sent();\n              return [4 /*yield*/, interactiveIsomorphicRequest.respondWith.invoked()];\n            case 2:\n              _a = __read.apply(void 0, [_b.sent(), 1]), mockedResponse = _a[0];\n              this.log('event.respondWith called with:', mockedResponse);\n              return [2 /*return*/, mockedResponse];\n          }\n        });\n      });\n    }).then(function (_a) {\n      var e_1, _b;\n      var _c = __read(_a, 2),\n        resolverException = _c[0],\n        mockedResponse = _c[1];\n      _this.log('the listeners promise awaited!');\n      // Halt the request whenever the resolver throws an exception.\n      if (resolverException) {\n        _this.log('encountered resolver exception, aborting request...', resolverException);\n        _this.emit('error', resolverException);\n        _this.terminate();\n        return _this;\n      }\n      if (mockedResponse) {\n        _this.log('received mocked response:', mockedResponse);\n        _this.responseSource = 'mock';\n        var isomorphicResponse = toIsoResponse_1.toIsoResponse(mockedResponse);\n        _this.respondWith(mockedResponse);\n        _this.log(isomorphicResponse.status, isomorphicResponse.statusText, isomorphicResponse.body, '(MOCKED)');\n        callback === null || callback === void 0 ? void 0 : callback();\n        _this.log('emitting the custom \"response\" event...');\n        _this.emitter.emit('response', isomorphicRequest, isomorphicResponse);\n        return _this;\n      }\n      _this.log('no mocked response received!');\n      // Set the response source to \"bypass\".\n      // Any errors emitted past this point are not suppressed.\n      _this.responseSource = 'bypass';\n      // Propagate previously captured errors.\n      // For example, a ECONNREFUSED error when connecting to a non-existing host.\n      if (_this.capturedError) {\n        _this.emit('error', _this.capturedError);\n        return _this;\n      }\n      // Write the request body chunks in the order of \".write()\" calls.\n      // Note that no request body has been written prior to this point\n      // in order to prevent the Socket to communicate with a potentially\n      // existing server.\n      _this.log('writing request chunks...', _this.chunks);\n      try {\n        for (var _d = __values(_this.chunks), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var _f = _e.value,\n            chunk_1 = _f.chunk,\n            encoding_1 = _f.encoding;\n          if (encoding_1) {\n            _super.prototype.write.call(_this, chunk_1, encoding_1);\n          } else {\n            _super.prototype.write.call(_this, chunk_1);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      _this.once('error', function (error) {\n        _this.log('original request error:', error);\n      });\n      _this.once('abort', function () {\n        _this.log('original request aborted!');\n      });\n      _this.once('response-internal', function (response) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var responseBody;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4 /*yield*/, getIncomingMessageBody_1.getIncomingMessageBody(response)];\n              case 1:\n                responseBody = _a.sent();\n                this.log(response.statusCode, response.statusMessage, responseBody);\n                this.log('original response headers:', response.headers);\n                this.log('emitting the custom \"response\" event...');\n                this.emitter.emit('response', isomorphicRequest, {\n                  status: response.statusCode || 200,\n                  statusText: response.statusMessage || 'OK',\n                  headers: headers_polyfill_1.objectToHeaders(response.headers),\n                  body: responseBody\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      });\n      _this.log('performing original request...');\n      return _super.prototype.end.apply(_this, __spreadArray([], __read([chunk, encoding, function () {\n        _this.log('original request end!');\n        callback === null || callback === void 0 ? void 0 : callback();\n      }].filter(Boolean))));\n    });\n    return this;\n  };\n  NodeClientRequest.prototype.emit = function (event) {\n    var data = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n    this.log('event:%s', event);\n    if (event === 'response') {\n      this.log('found \"response\" event, cloning the response...');\n      try {\n        /**\n         * Clone the response object when emitting the \"response\" event.\n         * This prevents the response body stream from locking\n         * and allows reading it twice:\n         * 1. Internal \"response\" event from the observer.\n         * 2. Any external response body listeners.\n         * @see https://github.com/mswjs/interceptors/issues/161\n         */\n        var response = data[0];\n        var firstClone = cloneIncomingMessage_1.cloneIncomingMessage(response);\n        var secondClone = cloneIncomingMessage_1.cloneIncomingMessage(response);\n        this.emit('response-internal', secondClone);\n        this.log('response successfully cloned, emitting \"response\" event...');\n        return _super.prototype.emit.apply(this, __spreadArray([event, firstClone], __read(data.slice(1))));\n      } catch (error) {\n        this.log('error when cloning response:', error);\n        return _super.prototype.emit.apply(this, __spreadArray([event], __read(data)));\n      }\n    }\n    if (event === 'error') {\n      var error = data[0];\n      var errorCode = error.code || '';\n      this.log('error:\\n', error);\n      // Suppress certain errors while using the \"mock\" source.\n      // For example, no need to destroy this request if it connects\n      // to a non-existing hostname but has a mocked response.\n      if (this.responseSource === 'mock' && NodeClientRequest.suppressErrorCodes.includes(errorCode)) {\n        // Capture the first emitted error in order to replay\n        // it later if this request won't have any mocked response.\n        if (!this.capturedError) {\n          this.capturedError = error;\n          this.log('captured the first error:', this.capturedError);\n        }\n        return false;\n      }\n    }\n    return _super.prototype.emit.apply(this, __spreadArray([event], __read(data)));\n  };\n  NodeClientRequest.prototype.respondWith = function (mockedResponse) {\n    var e_2, _a, _b;\n    this.log('responding with a mocked response...', mockedResponse);\n    var status = mockedResponse.status,\n      statusText = mockedResponse.statusText,\n      headers = mockedResponse.headers,\n      body = mockedResponse.body;\n    this.response.statusCode = status;\n    this.response.statusMessage = statusText;\n    if (headers) {\n      this.response.headers = {};\n      try {\n        for (var _c = __values(Object.entries(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var _e = __read(_d.value, 2),\n            headerName = _e[0],\n            headerValue = _e[1];\n          (_b = this.response.rawHeaders).push.apply(_b, __spreadArray([headerName], __read(Array.isArray(headerValue) ? headerValue : [headerValue])));\n          var insensitiveHeaderName = headerName.toLowerCase();\n          var prevHeaders = this.response.headers[insensitiveHeaderName];\n          this.response.headers[insensitiveHeaderName] = prevHeaders ? Array.prototype.concat([], prevHeaders, headerValue) : headerValue;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    this.log('mocked response headers ready:', headers);\n    if (body) {\n      this.response.push(Buffer.from(body));\n    }\n    // Push \"null\" to indicate that the response body is complete\n    // and shouldn't be written to anymore.\n    this.response.push(null);\n    this.response.complete = true;\n    /**\n     * Set the internal \"res\" property to the mocked \"OutgoingMessage\"\n     * to make the \"ClientRequest\" instance think there's data received\n     * from the socket.\n     * @see https://github.com/nodejs/node/blob/9c405f2591f5833d0247ed0fafdcd68c5b14ce7a/lib/_http_client.js#L501\n     */\n    // @ts-ignore\n    this.res = this.response;\n    this.finished = true;\n    Object.defineProperty(this, 'writableEnded', {\n      value: true\n    });\n    this.emit('finish');\n    this.emit('response', this.response);\n    this.terminate();\n  };\n  /**\n   * Terminates a pending request.\n   */\n  NodeClientRequest.prototype.terminate = function () {\n    var _a;\n    // @ts-ignore\n    (_a = this.agent) === null || _a === void 0 ? void 0 : _a.destroy();\n  };\n  NodeClientRequest.prototype.getRequestBody = function (chunk) {\n    var writtenRequestBody = bodyBufferToString_1.bodyBufferToString(Buffer.concat(this.requestBody));\n    this.log('written request body:', writtenRequestBody);\n    // Write the last request body chunk to the internal request body buffer.\n    if (chunk) {\n      this.requestBody = concatChunkToBuffer_1.concatChunkToBuffer(chunk, this.requestBody);\n    }\n    var resolvedRequestBody = Buffer.concat(this.requestBody);\n    this.log('resolved request body:', resolvedRequestBody);\n    return bufferUtils_1.getArrayBuffer(resolvedRequestBody);\n  };\n  NodeClientRequest.prototype.toIsomorphicRequest = function (body) {\n    var e_3, _a;\n    this.log('creating isomorphic request object...');\n    var outgoingHeaders = this.getHeaders();\n    this.log('request outgoing headers:', outgoingHeaders);\n    var headers = new headers_polyfill_1.Headers();\n    try {\n      for (var _b = __values(Object.entries(outgoingHeaders)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          headerName = _d[0],\n          headerValue = _d[1];\n        if (!headerValue) {\n          continue;\n        }\n        headers.set(headerName.toLowerCase(), headerValue.toString());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    var isomorphicRequest = new IsomorphicRequest_1.IsomorphicRequest(this.url, {\n      body: body,\n      method: this.options.method || 'GET',\n      credentials: 'same-origin',\n      headers: headers\n    });\n    this.log('successfully created isomorphic request!', isomorphicRequest);\n    return isomorphicRequest;\n  };\n  /**\n   * The list of internal Node.js errors to suppress while\n   * using the \"mock\" response source.\n   */\n  NodeClientRequest.suppressErrorCodes = ['ENOTFOUND', 'ECONNREFUSED', 'ECONNRESET', 'EAI_AGAIN'];\n  return NodeClientRequest;\n}(http_1.ClientRequest);\nexports.NodeClientRequest = NodeClientRequest;","map":{"version":3,"names":["http_1","require","until_1","headers_polyfill_1","concatChunkToBuffer_1","normalizeClientRequestEndArgs_1","toIsoResponse_1","getIncomingMessageBody_1","bodyBufferToString_1","normalizeClientRequestWriteArgs_1","cloneIncomingMessage_1","IsomorphicRequest_1","InteractiveIsomorphicRequest_1","bufferUtils_1","NodeClientRequest","_super","__extends","_a","options","_b","__read","url","requestOptions","callback","_this","call","chunks","responseSource","requestBody","log","extend","method","href","emitter","response","IncomingMessage","socket","prototype","write","args","_i","arguments","length","normalizeClientRequestWriteArgs","chunk","encoding","push","concatChunkToBuffer","end","normalizeClientRequestEndArgs","apply","__spreadArray","getRequestBody","isomorphicRequest","toIsomorphicRequest","interactiveIsomorphicRequest","InteractiveIsomorphicRequest","listenerCount","emit","until","__awaiter","untilIdle","request","id","sent","respondWith","invoked","mockedResponse","then","_c","resolverException","terminate","isomorphicResponse","toIsoResponse","status","statusText","body","capturedError","_d","__values","_e","next","done","_f","value","chunk_1","encoding_1","once","error","getIncomingMessageBody","responseBody","statusCode","statusMessage","headers","objectToHeaders","filter","Boolean","event","data","firstClone","cloneIncomingMessage","secondClone","slice","errorCode","code","suppressErrorCodes","includes","Object","entries","headerName","headerValue","rawHeaders","Array","isArray","insensitiveHeaderName","toLowerCase","prevHeaders","concat","Buffer","from","complete","res","finished","defineProperty","agent","destroy","writtenRequestBody","bodyBufferToString","resolvedRequestBody","getArrayBuffer","outgoingHeaders","getHeaders","Headers","set","toString","IsomorphicRequest","credentials","ClientRequest","exports"],"sources":["/Users/kyoungseo/Desktop/4학년/카테캠/step2/kakao-gift5/react-product-login/node_modules/@mswjs/interceptors/src/interceptors/ClientRequest/NodeClientRequest.ts"],"sourcesContent":["import type { Debugger } from 'debug'\nimport type { RequestOptions } from 'http'\nimport { ClientRequest, IncomingMessage } from 'http'\nimport { until } from '@open-draft/until'\nimport { Headers, objectToHeaders } from 'headers-polyfill'\nimport { MockedResponse } from '../../glossary'\nimport type { ClientRequestEmitter } from '.'\nimport { concatChunkToBuffer } from './utils/concatChunkToBuffer'\nimport {\n  ClientRequestEndChunk,\n  normalizeClientRequestEndArgs,\n} from './utils/normalizeClientRequestEndArgs'\nimport { NormalizedClientRequestArgs } from './utils/normalizeClientRequestArgs'\nimport { toIsoResponse } from '../../utils/toIsoResponse'\nimport { getIncomingMessageBody } from './utils/getIncomingMessageBody'\nimport { bodyBufferToString } from './utils/bodyBufferToString'\nimport {\n  ClientRequestWriteArgs,\n  normalizeClientRequestWriteArgs,\n} from './utils/normalizeClientRequestWriteArgs'\nimport { cloneIncomingMessage } from './utils/cloneIncomingMessage'\nimport { IsomorphicRequest } from '../../IsomorphicRequest'\nimport { InteractiveIsomorphicRequest } from '../../InteractiveIsomorphicRequest'\nimport { getArrayBuffer } from '../../utils/bufferUtils'\n\nexport type Protocol = 'http' | 'https'\n\nexport interface NodeClientOptions {\n  emitter: ClientRequestEmitter\n  log: Debugger\n}\n\nexport class NodeClientRequest extends ClientRequest {\n  /**\n   * The list of internal Node.js errors to suppress while\n   * using the \"mock\" response source.\n   */\n  static suppressErrorCodes = [\n    'ENOTFOUND',\n    'ECONNREFUSED',\n    'ECONNRESET',\n    'EAI_AGAIN',\n  ]\n\n  private url: URL\n  private options: RequestOptions\n  private response: IncomingMessage\n  private emitter: ClientRequestEmitter\n  private log: Debugger\n  private chunks: Array<{\n    chunk?: string | Buffer\n    encoding?: BufferEncoding\n  }> = []\n  private responseSource: 'mock' | 'bypass' = 'mock'\n  private capturedError?: NodeJS.ErrnoException\n\n  public requestBody: Buffer[] = []\n\n  constructor(\n    [url, requestOptions, callback]: NormalizedClientRequestArgs,\n    options: NodeClientOptions\n  ) {\n    super(requestOptions, callback)\n\n    this.log = options.log.extend(\n      `request ${requestOptions.method} ${url.href}`\n    )\n\n    this.log('constructing ClientRequest using options:', {\n      url,\n      requestOptions,\n      callback,\n    })\n\n    this.url = url\n    this.options = requestOptions\n    this.emitter = options.emitter\n\n    // Construct a mocked response message.\n    this.response = new IncomingMessage(this.socket!)\n  }\n\n  write(...args: ClientRequestWriteArgs): boolean {\n    const [chunk, encoding, callback] = normalizeClientRequestWriteArgs(args)\n    this.log('write:', { chunk, encoding, callback })\n    this.chunks.push({ chunk, encoding })\n    this.requestBody = concatChunkToBuffer(chunk, this.requestBody)\n    this.log('chunk successfully stored!', this.requestBody)\n\n    /**\n     * Prevent invoking the callback if the written chunk is empty.\n     * @see https://nodejs.org/api/http.html#requestwritechunk-encoding-callback\n     */\n    if (!chunk || chunk.length === 0) {\n      this.log('written chunk is empty, skipping callback...')\n    } else {\n      callback?.()\n    }\n\n    // Do not write the request body chunks to prevent\n    // the Socket from sending data to a potentially existing\n    // server when there is a mocked response defined.\n    return true\n  }\n\n  end(...args: any): this {\n    this.log('end', args)\n\n    const [chunk, encoding, callback] = normalizeClientRequestEndArgs(...args)\n    this.log('normalized arguments:', { chunk, encoding, callback })\n\n    const requestBody = this.getRequestBody(chunk)\n    const isomorphicRequest = this.toIsomorphicRequest(requestBody)\n    const interactiveIsomorphicRequest = new InteractiveIsomorphicRequest(\n      isomorphicRequest\n    )\n\n    // Notify the interceptor about the request.\n    // This will call any \"request\" listeners the users have.\n    this.log(\n      'emitting the \"request\" event for %d listener(s)...',\n      this.emitter.listenerCount('request')\n    )\n    this.emitter.emit('request', interactiveIsomorphicRequest)\n\n    // Execute the resolver Promise like a side-effect.\n    // Node.js 16 forces \"ClientRequest.end\" to be synchronous and return \"this\".\n    until(async () => {\n      await this.emitter.untilIdle('request', ({ args: [request] }) => {\n        /**\n         * @note Await only those listeners that are relevant to this request.\n         * This prevents extraneous parallel request from blocking the resolution\n         * of another, unrelated request. For example, during response patching,\n         * when request resolution is nested.\n         */\n        return request.id === interactiveIsomorphicRequest.id\n      })\n\n      const [mockedResponse] =\n        await interactiveIsomorphicRequest.respondWith.invoked()\n      this.log('event.respondWith called with:', mockedResponse)\n\n      return mockedResponse\n    }).then(([resolverException, mockedResponse]) => {\n      this.log('the listeners promise awaited!')\n\n      // Halt the request whenever the resolver throws an exception.\n      if (resolverException) {\n        this.log(\n          'encountered resolver exception, aborting request...',\n          resolverException\n        )\n        this.emit('error', resolverException)\n        this.terminate()\n\n        return this\n      }\n\n      if (mockedResponse) {\n        this.log('received mocked response:', mockedResponse)\n        this.responseSource = 'mock'\n\n        const isomorphicResponse = toIsoResponse(mockedResponse)\n        this.respondWith(mockedResponse)\n        this.log(\n          isomorphicResponse.status,\n          isomorphicResponse.statusText,\n          isomorphicResponse.body,\n          '(MOCKED)'\n        )\n\n        callback?.()\n\n        this.log('emitting the custom \"response\" event...')\n\n        this.emitter.emit('response', isomorphicRequest, isomorphicResponse)\n\n        return this\n      }\n\n      this.log('no mocked response received!')\n\n      // Set the response source to \"bypass\".\n      // Any errors emitted past this point are not suppressed.\n      this.responseSource = 'bypass'\n\n      // Propagate previously captured errors.\n      // For example, a ECONNREFUSED error when connecting to a non-existing host.\n      if (this.capturedError) {\n        this.emit('error', this.capturedError)\n        return this\n      }\n\n      // Write the request body chunks in the order of \".write()\" calls.\n      // Note that no request body has been written prior to this point\n      // in order to prevent the Socket to communicate with a potentially\n      // existing server.\n      this.log('writing request chunks...', this.chunks)\n\n      for (const { chunk, encoding } of this.chunks) {\n        if (encoding) {\n          super.write(chunk, encoding)\n        } else {\n          super.write(chunk)\n        }\n      }\n\n      this.once('error', (error) => {\n        this.log('original request error:', error)\n      })\n\n      this.once('abort', () => {\n        this.log('original request aborted!')\n      })\n\n      this.once('response-internal', async (response: IncomingMessage) => {\n        const responseBody = await getIncomingMessageBody(response)\n        this.log(response.statusCode, response.statusMessage, responseBody)\n        this.log('original response headers:', response.headers)\n\n        this.log('emitting the custom \"response\" event...')\n        this.emitter.emit('response', isomorphicRequest, {\n          status: response.statusCode || 200,\n          statusText: response.statusMessage || 'OK',\n          headers: objectToHeaders(response.headers),\n          body: responseBody,\n        })\n      })\n\n      this.log('performing original request...')\n\n      return super.end(\n        ...[\n          chunk,\n          encoding as any,\n          () => {\n            this.log('original request end!')\n            callback?.()\n          },\n        ].filter(Boolean)\n      )\n    })\n\n    return this\n  }\n\n  emit(event: string, ...data: any[]) {\n    this.log('event:%s', event)\n\n    if (event === 'response') {\n      this.log('found \"response\" event, cloning the response...')\n\n      try {\n        /**\n         * Clone the response object when emitting the \"response\" event.\n         * This prevents the response body stream from locking\n         * and allows reading it twice:\n         * 1. Internal \"response\" event from the observer.\n         * 2. Any external response body listeners.\n         * @see https://github.com/mswjs/interceptors/issues/161\n         */\n        const response = data[0] as IncomingMessage\n        const firstClone = cloneIncomingMessage(response)\n        const secondClone = cloneIncomingMessage(response)\n\n        this.emit('response-internal', secondClone)\n\n        this.log('response successfully cloned, emitting \"response\" event...')\n        return super.emit(event, firstClone, ...data.slice(1))\n      } catch (error) {\n        this.log('error when cloning response:', error)\n        return super.emit(event, ...data)\n      }\n    }\n\n    if (event === 'error') {\n      const error = data[0] as NodeJS.ErrnoException\n      const errorCode = error.code || ''\n\n      this.log('error:\\n', error)\n\n      // Suppress certain errors while using the \"mock\" source.\n      // For example, no need to destroy this request if it connects\n      // to a non-existing hostname but has a mocked response.\n      if (\n        this.responseSource === 'mock' &&\n        NodeClientRequest.suppressErrorCodes.includes(errorCode)\n      ) {\n        // Capture the first emitted error in order to replay\n        // it later if this request won't have any mocked response.\n        if (!this.capturedError) {\n          this.capturedError = error\n          this.log('captured the first error:', this.capturedError)\n        }\n        return false\n      }\n    }\n\n    return super.emit(event, ...data)\n  }\n\n  private respondWith(mockedResponse: MockedResponse): void {\n    this.log('responding with a mocked response...', mockedResponse)\n\n    const { status, statusText, headers, body } = mockedResponse\n    this.response.statusCode = status\n    this.response.statusMessage = statusText\n\n    if (headers) {\n      this.response.headers = {}\n\n      for (const [headerName, headerValue] of Object.entries(headers)) {\n        this.response.rawHeaders.push(\n          headerName,\n          ...(Array.isArray(headerValue) ? headerValue : [headerValue])\n        )\n\n        const insensitiveHeaderName = headerName.toLowerCase()\n        const prevHeaders = this.response.headers[insensitiveHeaderName]\n        this.response.headers[insensitiveHeaderName] = prevHeaders\n          ? Array.prototype.concat([], prevHeaders, headerValue)\n          : headerValue\n      }\n    }\n    this.log('mocked response headers ready:', headers)\n\n    if (body) {\n      this.response.push(Buffer.from(body))\n    }\n\n    // Push \"null\" to indicate that the response body is complete\n    // and shouldn't be written to anymore.\n    this.response.push(null)\n    this.response.complete = true\n\n    /**\n     * Set the internal \"res\" property to the mocked \"OutgoingMessage\"\n     * to make the \"ClientRequest\" instance think there's data received\n     * from the socket.\n     * @see https://github.com/nodejs/node/blob/9c405f2591f5833d0247ed0fafdcd68c5b14ce7a/lib/_http_client.js#L501\n     */\n    // @ts-ignore\n    this.res = this.response\n\n    this.finished = true\n    Object.defineProperty(this, 'writableEnded', {\n      value: true,\n    })\n\n    this.emit('finish')\n    this.emit('response', this.response)\n\n    this.terminate()\n  }\n\n  /**\n   * Terminates a pending request.\n   */\n  private terminate(): void {\n    // @ts-ignore\n    this.agent?.destroy()\n  }\n\n  private getRequestBody(chunk: ClientRequestEndChunk | null): ArrayBuffer {\n    const writtenRequestBody = bodyBufferToString(\n      Buffer.concat(this.requestBody)\n    )\n    this.log('written request body:', writtenRequestBody)\n\n    // Write the last request body chunk to the internal request body buffer.\n    if (chunk) {\n      this.requestBody = concatChunkToBuffer(chunk, this.requestBody)\n    }\n\n    const resolvedRequestBody = Buffer.concat(this.requestBody)\n    this.log('resolved request body:', resolvedRequestBody)\n\n    return getArrayBuffer(resolvedRequestBody)\n  }\n\n  private toIsomorphicRequest(body: ArrayBuffer): IsomorphicRequest {\n    this.log('creating isomorphic request object...')\n\n    const outgoingHeaders = this.getHeaders()\n    this.log('request outgoing headers:', outgoingHeaders)\n\n    const headers = new Headers()\n    for (const [headerName, headerValue] of Object.entries(outgoingHeaders)) {\n      if (!headerValue) {\n        continue\n      }\n\n      headers.set(headerName.toLowerCase(), headerValue.toString())\n    }\n\n    const isomorphicRequest = new IsomorphicRequest(this.url, {\n      body,\n      method: this.options.method || 'GET',\n      credentials: 'same-origin',\n      headers,\n    })\n\n    this.log('successfully created isomorphic request!', isomorphicRequest)\n    return isomorphicRequest\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}