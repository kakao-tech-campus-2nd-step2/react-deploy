# **경북대 FE\_정솔빈\_6주차 과제 Week 6**

## 1단계 - API 명세 협의 & 반영

**구현 목록:**

- [ ] 팀 내 여러 API가 있을 시 네비게이션 바에서 선택하는 기능 -> 백엔드 조원분들 API 통일
- [x] API 반영
- [x] '카카오로 로그인하기' 버튼 생성
- [ ] 주문 목록 페이지 생성 -> 제대로 실행되지 않는 상태
- [x] 상품 상세 페이지에서 옵션 선택 가능하도록 구현

## 2단계 - 배포하기

- [x] github pages를 사용하여 배포하기

## 4단계 - 질문의 답변을 README에 작성

- 질문 1. SPA 페이지를 정적 배포를 하려고 할 때 Vercel을 사용하지 않고 한다면 어떻게 할 수 있을까요?
  정적 배포는 웹 애플리케이션을 서버에서 동적인 처리를 하지 않고, 미리 생성된 정적 파일들만을 클라이언트에 제공하는 배포 방식입니다. 서버 부하가 적고, 콘텐츠 로딩 속도가 빠르며, 보안성이 높다는 장점이 있습니다.

  Vercel을 사용하지 않고 한다면 github page를 이용할 수 있습니다. 이번 과제도 github page를 이용해서 배포했으며 gh-pages 브랜치를 사용하고 Github 설정에서 pages를 설정하고 결과물을 푸시하면 배포가 됩니다. 또 다른 방법으로는 AWS를 이용할 수 있습니다.

- 질문 2. CSRF나 XSS 공격을 막는 방법은 무엇일까요?
  CSRF 공격은 사용자가 인증된 상태에서 악의적인 사이트가 사용자의 자격 증명을 사용해 요청을 보낼 수 있도록 하는 공격입니다. 대표적으로 CSRF 토큰을 사용해 막을 수 있습니다. CSRF 토큰은 서버가 클라이언트에 발급한 고유한 값입니다. 사용자가 폼을 제출할 때 이 토큰을 함께 보내고, 서버는 이 토큰을 검증하여 요청이 유효한지 확인히먄 토큰을 알 수 없으므로 CSRF 공격을 방지할 수 있습니다.

  XSS 공격은 악성 스크립트를 웹 페이지에 삽입하여 사용자의 브라우저에서 실행시키는 공격입니다. 예를 들어 댓글 창에 `<script>alert('XSS 공격!');</script>` 이 내용을 넣으면 웹 페이지 사용자에게 위 alert창이 보입니다. XSS 공격을 막을 수 있는 첫 번째 방법은 사용자 입력을 서버에 저장하거나 표시하기 전에 인코딩하거나 이스케이프 처리하는 방법입니다. 예를 들어, HTML 태그나 스크립트 코드를 안전하게 변환하여 실행되지 않도록 합니다. 두 번째 방법은 Content Security Policy(CSP)를 설정하여 스크립트가 신뢰할 수 있는 출처에서만 로드되도록 제한하는 방법입니다. 세번째로 사용자 입력을 검증하고 필터링하여 의도하지 않은 스크립트 코드가 포함되지 않도록 하는 방법도 있습니다. 마지막으로, JavaScript를 직접 작성하는 경우, eval 함수와 같은 동적 코드 실행을 피하고, 외부 라이브러리나 플러그인을 사용할 때는 신뢰할 수 있는 출처에서만 가져오는 방법으로 XSS공격을 막을 수 있습니다.

- 질문 3. 브라우저 렌더링 원리에대해 설명해주세요.
  사용자가 웹 페이지를 요청하면, 브라우저는 HTML 문서를 서버로부터 받아와서 이를 파싱하여 웹 페이지의 구조와 내용을 트리 형태인 DOM구조로 변환합니다. HTML과 함께 CSS 스타일시트도 다운로드되며, 브라우저는 이 CSS를 파싱하여 CSSOM을 생성합니다. CSSOM은 스타일 규칙을 트리 구조로 변환하여 적용할 준비를 합니다.

  DOM과 CSSOM을 결합하여 Render Tree를 구성합니다. 렌더 트리는 화면에 표시될 요소와 이들 요소의 스타일 정보를 포함하며, DOM 트리와는 달리 숨겨진 요소나 스타일이 적용되지 않은 요소는 포함되지 않습니다. 이후, 렌더 트리를 기반으로 각 요소의 위치와 크기를 계산하는 레이아웃 단계가 진행됩니다. 이 단계에서는 페이지 내에서 각 요소가 어디에 배치될지 결정하며, 요소의 위치와 크기, 오버플로우 등이 계산됩니다.

  레이아웃 계산이 완료되면, 브라우저는 실제로 화면에 콘텐츠를 그립니다. 이 단계에서는 텍스트, 색상, 배경 이미지 등 시각적인 스타일이 요소에 적용되며, 화면의 픽셀을 수정하여 요소의 최종 외형을 만듭니다. 마지막으로, 각 요소가 어떻게 화면에 쌓일지를 결정하는 단계가 진행됩니다. 이때 복잡한 페이지에서는 여러 레이어가 사용될 수 있습니다. 이 레이어들은 서로 겹치는 방식에 따라 최종적인 화면 이미지를 생성합니다.
