# react-deploy

## 🚀 0단계 - 기본 코드 준비

### 기능 요구 사항

> 로그인 및 관심목록 코드를 옮겨 온다. 코드를 옮기는 방법에는 디렉터리의 모든 파일을 직접 복사하여 붙여 넣는 것부터 필요한 일부 파일만 이동하는 것, Git을 사용하는 것까지 여러 가지 방법이 있다. 코드 이동 시 반드시 **리소스 파일, 프로퍼티 파일, 테스트 코드** 등을 함께 이동한다.

## 🚀 1단계 - API 명세 협의 & 반영

### 기능 요구 사항

- 작성한 API 문서를 기반으로 팀 내에서 지금까지 만든 API를 검토하고 통일하여 변경 사항을 반영한다.

- [ ] 팀 내에서 일관된 기준을 정하여 API 명세를 결정한다.
- [ ] 때로는 클라이언트의 편의를 위해 API 명세를 결정하는 것이 좋다.
- [x] 팀 내에 배포 될 API가 여러개 일 경우 상단 네비게이션 바에서 선택 가능하게 한다.
  - [x] 프론트엔드의 경우 배포와 사용자가 팀 내 여러 서버 중 하나를 선택하여 서비스를 이용
  - [x] 팀내 백엔드 엔지니어의 이름을 넣고, 이름을 선택하면 해당 엔지니어의 API로 API통신을 하게 한다.
  - [x] 기본 선택은 제일 첫번째 이름으로 한다.

## 🚀 2단계 - 배포하기

### 기능 요구 사항

- 세가지 방법 중 본인이 원하는 방식으로 배포한다.

  (단, 가능하면 최대한 방법 1, 3번으로 진행하고 CI/CD를 구축하는 것을 권장)

- 방법1.
  - github action을 사용하여 ci/cd를 구성한다.
  - cloudflare의 pages에 배포한다.
- 방법2.
  - vercel을 사용하여 배포한다.
- 방법3.
  - github pages를 사용하여 배포한다.
    서버 API가 의도대로 잘 동작하는지 확인하고, 문제가 있다면 해결한다.
- [x] 방법3 사용하여 배포 완료.
  - HTTP로 요청을 보내려하여 Mixed Content 오류 발생

## 🚀 3단계 - 포인트

### 기능 요구 사항

- 상품 구매에 사용 가능한 포인트 기능 구현
- [ ] 포인트는 사용자별로 보유
- [ ] 포인트 차감 방법 등 나머지 기능에 대해서는 팀과 논의하여 정책을 결정하고 구현
  - e.g.
    - 5만 원 이상 주문 시 총 금액의 10%가 할인됨
    - 현금 영수증을 받으려면 휴대전화 번호를 입력해야 함
- [ ] API 명세는 팀과 협의하여 결정하고 구현

## 🚀 4단계 - 질문의 답변을 README에 작성

### 📝 Requirements

### 6주차 질문

- **질문 1. SPA 페이지를 정적 배포를 하려고 할 때 Vercel을 사용하지 않고 한다면 어떻게 할 수 있을까요?**

  정적 배포는 미리 생성된 HTML, CSS, JavaScript 파일을 서버에 업로드하여 배포하는 방식이다. SPA 페이지의 정적 배포 방법으로는 Vercel을 사용할수 있으며, 이밖에도 `Netlify Github Page, Cloudflare Pages, AWS S3 + CloudFront`를 이용하여 배포가 가능하다.
  특히 이번 주차에서는 Github Page를 사용하여 배포를 해보았는데, 과정은 다음과 같았다.

  ```
  1. gh-pages 설치(npm install --save gh-pages)
  2. package.json 파일에 homapage 필드 추가 후, Github Pages 주소를 적어줌
  3. script 필드에 predeploy, deploy 추가
  4. 배포 (npm run deploy)
  5. Github에서 Setting > Github Pages > Source에서 branch를 gh-pages로 변경
  ```

- **질문 2. CSRF나 XSS 공격을 막는 방법은 무엇일까요?**

  - **CSRF 공격**은 사용자가 인증된 상태에서 공격자가 준비한 악의적인 요청을 서버에 전송하게 만들어, 사용자의 의지와는 무관하게 공격자가 원하는대로 행동하게 만드는 공격이다.

    따라서 이를 방지하기 위해 `CSRF 토큰을 사용`할 수 있다. 서버는 각 요청이 들어오면 고유한 CSRF 토큰을 생성해 클라이언트에 전달하고, 클라이언트는 이 토큰을 다음 요청에 포함시켜 서버에 전송하는 식이다. 서버는 요청이 들어올 때 이 토큰을 검증하여 요청의 정당성을 확인할 수 있다.

    `SameSite` 쿠키 속성을 설정하는 것 또한 CSRF 공격을 방지하는 또 다른 방법이다. 이를 통해 쿠키가 다른 사이트의 요청에 의해 사용되지 않도록 할 수 있다.

  - **XSS 공격**은 공격자가 웹 페이지에 악성 스크립트를 삽입하여 사용자의 브라우저에서 실행되도록 하는 공격이다. 이를 통해 공격자는 사용자의 세션 쿠키를 탈취할 수도 있다.

    이를 막기 위한 방법으로 `입력 데이터 검증 및 인코딩`, `Content Security Policy (CSP) 설정` 등이 있다.

    `입력 데이터 검증 및 인코딩`은 말그대로 사용자 입력을 철저히 검증하고, 필요에 따라 인코딩하여 스크립트가 실행되지 않도록 하는 방법이다.

    `Content Security Policy`는 CSP 헤더를 설정하여 허용된 소스에서만 스크립트가 로드되고 실행되도록 하는 방법으로, 이를 통해서도 XSS 공격을 막을 수 있다.

- **질문 3. 브라우저 렌더링 원리에대해 설명해주세요.**
  1. 브라우저는 서버로부터 HTML 문서를 전달받는다.(Loader가 서버로부터 HTML을 불러온다.)
  2. 렌더링 엔진은 전달받은 HTML 문서를 읽고 분석해서 DOM 트리를 만든다.
  3. CSS를 파싱하여 CSSOM(CSS Object Model) 트리를 생성한다.
  4. DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 만든다.
  - 이때 렌더 트리는 실제로 화면에 표시될 요소만 포함하는 트리이다. (display:none 속성을 가진 요소는 미포함)
  5. 렌더 트리의 요소들의 위치와 크기를 계산한다. (Layout)
  6. 계산된 레이아웃을 바탕으로 브라우저는 각 요소가 페이지에서 어디에 있어야 하는지를 결정한다. (Paint)
  7. 여러 레이어로 나뉘어진 요소들을 최종적으로 하나의 화면에 결합한다. (Composite)
